const https = require("https");
const http  = require("http");
const express = require("express");

const app = express();
const PORT = 3000;

/* ✅✅✅ 关键：全局允许跨域 */
app.use((req, res, next) => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type");
    next();
});



/* =========================
✅ ✅ ✅ 完全使用你原来的解析函数（一行没改）
========================= */
function resolveRedirect(url, depth = 0) {
    return new Promise((resolve, reject) => {
        const lib = url.startsWith("https") ? https : http;

        console.log(`➡️ 第 ${depth + 1} 次请求：`, url);

        const req = lib.get(url, { rejectUnauthorized: false }, res => {

            // ✅ 如果是 301 / 302 并且还有 location，就继续跟
            if (
                (res.statusCode === 301 || res.statusCode === 302 ) &&
                res.headers.location
            ) {
                const nextUrl = res.headers.location;

                res.destroy(); // ✅ 防止 socket 卡死

                // ✅ 递归继续请求
                return resolve(
                    resolveRedirect(nextUrl, depth + 1)
                );
            }

            // ✅ 如果不是跳转了，说明这是最终真实地址
            console.log("✅ 最终真实 m3u8 地址：\n");
            console.log(url);

            res.destroy();
            resolve(url);
        });

        req.on("error", err => {
            reject(err);
        });
    });
}

/* =========================
✅ 给前端调用的接口（仅做封装）
用法：/api/resolve?url=xxxx
========================= */
app.get("/api/resolve", async (req, res) => {
    const proxyUrl = req.query.url;

    if (!proxyUrl) {
        return res.json({
            success: false,
            msg: "缺少 url 参数"
        });
    }

    try {
        /* const finalUrl = await resolveRedirect(proxyUrl);

        res.json({
            success: true,
            proxy: proxyUrl,
            real: finalUrl
        });
		 */
		
		
		const realUrl = await resolveRedirect(proxyUrl);

		// ✅ 统一转为你自己的 Nginx 反代域名（终极稳定版）
		let proxiedUrl = realUrl;

		// ===== ✅ 1️⃣ 咪咕源（http / https 全兼容）=====
		/* proxiedUrl = proxiedUrl.replace(
			/^https?:\/\/hlszymgsplive\.miguvideo\.com:8080\//i,
			"https://migu.alltv.cc/mgmg/"
		); */

		// 兼容另外一些咪咕分发域（如果后面再出现，可以继续加）
		/* proxiedUrl = proxiedUrl.replace(
			/^https?:\/\/.*\.miguvideo\.com:8080\//i,
			"https://migu.alltv.cc/mgmg/"
		); */

		// ===== ✅ 2️⃣ 腾讯 CDN（txycdn / ltstysj 全家桶）=====
		/* proxiedUrl = proxiedUrl.replace(
			/^https?:\/\/txycdn\d*\.video\.qq\.com\//i,
			"https://nba.alltv.cc/tx/"
		);

		proxiedUrl = proxiedUrl.replace(
			/^https?:\/\/ltstysj\.gtimg\.com\//i,
			"https://nba.alltv.cc/tx/"
		); */

		// ===== ✅ 3️⃣ 兜底：如果不是已知域名，就原样返回（防止误伤）=====
		const finalUrl = proxiedUrl;

		res.json({
			success: true,
			proxy: proxyUrl,   // 原始 302 地址（调试用）
			real: finalUrl     // ✅ 播放器永远只播这个
		});




    } catch (err) {
        res.json({
            success: false,
            proxy: proxyUrl,
            error: err.message
        });
    }
});

/* ========================= */
app.listen(PORT, () => {
    console.log(`✅ 使用你原始解析逻辑的服务已启动：`);
    console.log(`✅ http://localhost:${PORT}/api/resolve?url=xxxx`);
});
